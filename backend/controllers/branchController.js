
// routes/branches.js (veya uygun controller i√ßinde)
const express = require('express');
const router = express.Router();
const Branch = require('../models/Branch');
const BranchProduct = require('../models/BranchProduct');
const Product = require('../models/Products');
const Business = require('../models/Business');
const Sequelize = require('../db');


exports.getProductsByBranchId = async (req, res) => {
  const { branchId } = req.params;

  try {
    // BranchProduct modelinden doƒürudan sorgulama yaparak istediƒüimiz ili≈ükilendirmeyi yapalƒ±m.
    // Bu, Branch.findByPk √ºzerinden gitmekten daha doƒürudan olabilir
    // ve daha okunaklƒ± bir sonu√ß objesi verir.
    const branchProducts = await BranchProduct.findAll({
      where: { branch_id: branchId },
      include: [
        {
          model: Product, // ƒ∞li≈ükili Product modelini dahil et
          attributes: ['product_name'], // Sadece product_name'i √ßekmek i√ßin attributes belirtildi
        },
      ],
      // BranchProduct'tan hangi s√ºtunlarƒ± √ßekmek istediƒüinizi burada belirtebilirsiniz.
      // Zaten branch_id ve product_id PK olduƒüu i√ßin otomatik gelir.
      attributes: ['branch_id', 'product_id', 'price', 'stock'],
    });

    // Gelen veriyi istediƒüiniz formata d√∂n√º≈üt√ºrme
    const formattedProducts = branchProducts.map(bp => ({
      branch_id: bp.branch_id,
      product_id: bp.product_id,
      product_name: bp.Product ? bp.Product.product_name : null, // Product ili≈ükisi null olabilir ihtimaline kar≈üƒ± kontrol
      price: bp.price,
      stock: bp.stock,
    }));

    return res.json(formattedProducts);
  } catch (err) {
    console.error("≈ûubeye baƒülƒ± √ºr√ºnleri getirme hatasƒ±:", err);
    res.status(500).json({ message: 'Sunucu hatasƒ±: ≈ûubeye baƒülƒ± √ºr√ºnler getirilemedi.' });
  }
};

// controllers/businessController.js

exports.getBusinessDetailsWithProducts = async (req, res) => {
  const { businessId } = req.params;

  try {
    const business = await Business.findByPk(businessId, {
      include: [
        {
          model: Branch,
          include: [
            {
              model: BranchProduct,
              include: [
                {
                  model: Product,
                  attributes: ['product_id', 'product_name', 'description', 'price'],
                },
              ],
            },
          ],
        },
      ],
    });

    if (!business) {
      return res.status(404).json({ message: 'ƒ∞≈ületme bulunamadƒ±' });
    }

    return res.json(business);
  } catch (error) {
    console.error('HATA:', error);
    return res.status(500).json({ message: 'Sunucu hatasƒ±' });
  }
};


exports.getAllBranchesByBusinessId = async (req, res) => {
    try {
      const { businessId } = req.params;
      console.log('üì¶ Gelen parametre:', req.params);

      if (!businessId) {
        return res.status(400).json({ error: 'business_id parametresi gerekli' });
      }
  
      const branches = await Branch.findAll({
        where: { business_id: businessId },
        order: [['id', 'ASC']],
      });

      console.log(branches);
      res.json(branches);
    } catch (err) {
      console.error('≈ûubeler alƒ±namadƒ±:', err);
      res.status(500).json({ error: '≈ûubeler alƒ±namadƒ±' });
    }
  };
  

  // POST /branches
exports.createBranch = async (req, res) => {
  try {
    const { name, adress, businessId} = req.body;

    const newBranch = await Branch.create({
      name,
      adress,
      business_id:businessId
    });

    res.status(201).json(newBranch);
  } catch (error) {
    console.error('≈ûube olu≈üturulamadƒ±:', error);
    res.status(500).json({ error: 'Sunucu hatasƒ±' });
  }
};

// PUT /branches/:id
exports.updateBranch = async (req, res) => {
  try {
    const { branchId } = req.params;
    const { name, adress } = req.body;

    const branch = await Branch.findByPk(branchId);
    if (!branch) {
      return res.status(404).json({ error: '≈ûube bulunamadƒ±' });
    }

    branch.name = name;
    branch.adress = adress;
    await branch.save();

    res.status(200).json(branch);
  } catch (error) {
    console.error('≈ûube g√ºncellenemedi:', error);
    res.status(500).json({ error: 'Sunucu hatasƒ±' });
  }
};

// DELETE /branches/:id
exports.deleteBranch = async (req, res) => {
  try {
    const { id } = req.params;

    const deleted = await Branch.destroy({ where: { id } });

    if (!deleted) {
      return res.status(404).json({ error: '≈ûube bulunamadƒ±' });
    }

    res.status(200).json({ success: true });
  } catch (error) {
    console.error('≈ûube silinemedi:', error);
    res.status(500).json({ error: 'Sunucu hatasƒ±' });
  }
};

// GET /branch/:id
exports.getBranchById = async (req, res) => {
  try {
    const { branchId } = req.params;

    const branch = await Branch.findByPk(branchId);
    if (!branch) {
      return res.status(404).json({ error: '≈ûube bulunamadƒ±' });
    }

    res.status(200).json(branch);
  } catch (error) {
    console.error('≈ûube alƒ±namadƒ±:', error);
    res.status(500).json({ error: 'Sunucu hatasƒ±' });
  }
};

// Yeni fonksiyon: Bir ≈üubeye baƒülƒ± √ºr√ºnleri getirme
// exports.getBranchProductsByBranchId = async (req, res) => {
//   try {
//     const { branchId } = req.params;

//     if (!branchId) {
//       return res.status(400).json({ error: "≈ûube ID'si eksik." });
//     }

//     // BranchProduct tablosundan ilgili ≈üubeye ait kayƒ±tlarƒ± ve Product bilgilerini √ßekme
//     const branchProducts = await BranchProduct.findAll({
//       where: { branch_id: branchId },
//       include: [
//         {
//           model: Product, // ƒ∞li≈ükili Product modelini dahil et
//           attributes: ['id', 'product_name', 'description', 'price', 'image_url'], // Product'tan istediƒüiniz alanlar
//         },
//       ],
//     });

//     if (!branchProducts || branchProducts.length === 0) {
//       return res.status(404).json({ message: 'Bu ≈üubeye ait √ºr√ºn bulunamadƒ±.' });
//     }

//     return res.status(200).json(branchProducts);
//   } catch (error) {
//     console.error('≈ûubeye baƒülƒ± √ºr√ºnleri getirme hatasƒ±:', error);
//     return res.status(500).json({ error: 'Sunucu hatasƒ±: ≈ûubeye baƒülƒ± √ºr√ºnler getirilemedi.' });
//   }
// };


exports.createBranchProduct = async (req, res) => {
  const { branch_id, product_id, price, stock } = req.body;

  try {
    // Zorunlu alan kontrol√º
    if (!branch_id || !product_id || price === undefined || stock === undefined) {
      return res.status(400).json({ error: "branch_id, product_id, price ve stock alanlarƒ± zorunludur." });
    }

    // ≈ûube ve √ºr√ºn√ºn ger√ßekten var olup olmadƒ±ƒüƒ±nƒ± kontrol et
    const branchExists = await Branch.findByPk(branch_id);
    const productExists = await Product.findByPk(product_id);

    if (!branchExists) {
      return res.status(404).json({ error: `Belirtilen ≈üube (ID: ${branch_id}) bulunamadƒ±.` });
    }
    if (!productExists) {
      return res.status(404).json({ error: `Belirtilen √ºr√ºn (ID: ${product_id}) bulunamadƒ±.` });
    }

    // Aynƒ± ≈üube ve √ºr√ºn kombinasyonunun zaten olup olmadƒ±ƒüƒ±nƒ± kontrol et
    const existingBranchProduct = await BranchProduct.findOne({
      where: {
        branch_id: branch_id,
        product_id: product_id,
      },
    });

    if (existingBranchProduct) {
      // Eƒüer mevcutsa, g√ºncelleyebilir veya hata d√∂nebilirsiniz.
      // Bu √∂rnekte, var olan bir kaydƒ± g√ºncellemek yerine, hata d√∂nd√ºr√ºyoruz.
      // ƒ∞sterseniz burada 'existingBranchProduct.update({ price, stock })' yapabilirsiniz.
      return res.status(409).json({ error: 'Bu √ºr√ºn zaten bu ≈üubeye eklenmi≈ü. Mevcut √ºr√ºn√º g√ºncelleyin.' });
    }

    // Yeni BranchProduct kaydƒ±nƒ± olu≈ütur
    const newBranchProduct = await BranchProduct.create({
      branch_id,
      product_id,
      price,
      stock,
    });

    return res.status(201).json(newBranchProduct);
  } catch (error) {
    console.error('≈ûubeye √ºr√ºn ekleme hatasƒ±:', error);
    res.status(500).json({ error: 'Sunucu hatasƒ±: √úr√ºn ≈üubeye eklenirken bir hata olu≈ütu.' });
  }
};


exports.AddProductToBranch= async (req, res) => {
  const transaction = await Sequelize.transaction();
  try {
    const { branch_id, product_ids } = req.body;

    if (!branch_id || !product_ids || !Array.isArray(product_ids)) {
      await transaction.rollback();
      return res.status(400).json({ 
        error: 'Ge√ßersiz istek. branch_id ve product_ids (array) gereklidir.' 
      });
    }

    const results = [];
    const errors = [];

    for (const product_id of product_ids) {
      try {
        // √úr√ºn√ºn business'a ait olduƒüunu kontrol et
        const product = await Product.findOne({
          where: { product_id: product_id },
          transaction
        });

        if (!product) {
          errors.push({ product_id, error: '√úr√ºn bulunamadƒ±' });
          continue;
        }

        // BranchProduct olu≈ütur
        const record = await BranchProduct.create({
          branch_id,
          product_id,
          price: 0, // Varsayƒ±lan deƒüer
          stock: 0  // Varsayƒ±lan deƒüer
        }, { transaction });

        results.push(record);
      } catch (error) {
        errors.push({ product_id, error: error.message });
      }
    }

    if (errors.length > 0 && results.length === 0) {
      await transaction.rollback();
      return res.status(400).json({ 
        error: 'Hi√ßbir √ºr√ºn eklenemedi',
        details: errors 
      });
    }

    await transaction.commit();
    
    res.status(201).json({
      message: `${results.length} √ºr√ºn ba≈üarƒ±yla eklendi`,
      added: results.length,
      failed: errors.length,
      successes: results.map(r => r.product_id),
      errors
    });
  } catch (error) {
    await transaction.rollback();
    console.error('√úr√ºn ekleme hatasƒ±:', error);
    res.status(500).json({ error: '√úr√ºn eklenirken bir hata olu≈ütu' });
  }
};

// ≈ûube √ºr√ºn√ºnde fiyat ve stok g√ºncelleme
exports.updateBranchProduct = async (req, res) => {
  try {
    const { branch_id, product_id, price, stock } = req.body;

    if (!branch_id || !product_id) {
      return res.status(400).json({ error: 'branch_id ve product_id zorunludur.' });
    }

    // Model adƒ±nƒ± ezmeden doƒüru kullan
    const branchProduct = await BranchProduct.findOne({
      where: { branch_id, product_id }
    });

    if (!branchProduct) {
      return res.status(404).json({ error: '≈ûubeye ait √ºr√ºn bulunamadƒ±.' });
    }

    // Fiyat ve stok g√ºncelle
    if (price !== undefined) branchProduct.price = price;
    if (stock !== undefined) branchProduct.stock = stock;

    await branchProduct.save();

    return res.status(200).json({ success: true, branchProduct });
  } catch (error) {
    console.error('≈ûube √ºr√ºn g√ºncelleme hatasƒ±:', error);
    return res.status(500).json({ error: 'Sunucu hatasƒ±: ≈ûube √ºr√ºn g√ºncellenemedi.' });
  }
};

// ≈ûubeye eklenebilecek √ºr√ºnleri getir (hen√ºz eklenmemi≈ü olanlar)
exports.getAvailableProductsForBranch = async (req, res) => {
  try {
    const { branchId, businessId } = req.params;

    if (!branchId || !businessId) {
      return res.status(400).json({ error: 'branchId ve businessId parametreleri zorunludur.' });
    }

    // √ñnce ≈üubeye ait √ºr√ºnlerin ID'lerini al
    const branchProducts = await BranchProduct.findAll({
      where: { branch_id: branchId },
      attributes: ['product_id']
    });

    const existingProductIds = branchProducts.map(bp => bp.product_id);

    // ƒ∞≈ületmeye ait t√ºm √ºr√ºnleri al, ancak ≈üubede olmayanlarƒ± filtrele
    const allProducts = await Product.findAll({
      where: { business_id: businessId },
      attributes: ['product_id', 'product_name', 'description', 'price', 'image_url']
    });

    // ≈ûubede olmayan √ºr√ºnleri filtrele
    const availableProducts = allProducts.filter(product => 
      !existingProductIds.includes(product.product_id)
    );

    return res.status(200).json(availableProducts);
  } catch (error) {
    console.error('≈ûubeye eklenebilecek √ºr√ºnleri getirme hatasƒ±:', error);
    return res.status(500).json({ error: 'Sunucu hatasƒ±: √úr√ºnler getirilemedi.' });
  }
};


exports.deleteBranchProduct = async (req, res) => {
  try {
    const { branch_id, product_id } = req.body;
    const deleted = await BranchProduct.destroy({
      where: { branch_id, product_id }
    });
    if (deleted) {
      return res.status(200).json({ success: true });
    }
    return res.status(404).json({ error: 'Kayƒ±t bulunamadƒ±' });
  } catch (error) {
    console.error('Silme hatasƒ±:', error);
    return res.status(500).json({ error: 'Silme i≈ülemi sƒ±rasƒ±nda hata olu≈ütu' });
  }
};








